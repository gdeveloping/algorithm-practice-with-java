# Coding Interviews 2

> 功能流 + 数据流 + 异常关注点

## 降低复杂度

1. 归纳总结规律
2. 蚕食复杂度

## 高质量代码

1. 规范性
   1. 清晰的书写
   2. 清晰的布局
   3. 合理的命名
2. 完整性
   1. 功能测试
   2. 边界测试
   3. 负面测试
   4. 错误处理
3. 鲁棒性（健壮性）
   1. 容错性
   2. 防御性编程
   3. 处理无效输入

## 关注点

1. 入参
   1. 入参校验
   2. 空指针
   3. 空白值
   4. 默认值
   5. 负面值
   6. 是否可以修改
2. 流程
   1. 循环流程
   2. 计数范围
   3. next 范围
3. 错误
   1. 0和负数
   2. 整数溢出，使用 long
   3. 堆栈溢出
   4. 自动拆装箱
   5. 数组/字符串/集合越界
4. 数据流
   1. 初始值
   2. 值的变化流程
   3. 最终值
5. 优化
   1. 用户使用习惯/人机交互习惯，如是否打印数字前的0
6. 问题
   1. 大数问题

## 描述

> 兼具抽象与具象

1. 画图——画图让抽象问题形象化
   1. 结构图
   2. 可视化
2. 举例——举例让抽象问题具体化
   1. 类比
   2. 实例
3. 分解——分解让复杂问题简单化
   1. 分解为子问题
   2. 分解为多个步骤
   3. 子问题 + 子问题间联系
   4. 子步骤 + 子步骤间联系

## 高性能代码

1. 时间复杂度
2. 空间复杂度
3. 位运算
4. 逻辑较为简单时：不使用对象 --> 使用小对象 --> 使用大对象 --> 使用多个对象，例 Offer50
5. 时间换空间
   1. Offer3 countRange
   2. Offer49 nthUglyNumber
6. 空间换时间
7. 修改源数据换空间
   1. Offer3 swap(nums[i], nums[nums[i]])
   2. Offer35 N0->N0'->N1->N1'
8. 修改源数据换时间

## 考察能力

1. 知识迁移能力
2. 抽象建模能力
3. 发散思维
4. 沟通能力
5. 学习能力

## 技巧

1. 着力点
   1. 有很多算法问题都需要排序后进行处理，当对问题无从下手时，可以尝试先排序。
2. 整洁代码
   1. Set: boolean add(E e) 将判断是否已存在 e 和添加 e 合并为一条命令
3. 转换
   1. 二维数组转化为二叉树
   2. 回溯转化为动态规划
4. tree
   1. order
   2. traverse

## Others
